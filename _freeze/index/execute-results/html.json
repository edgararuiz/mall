{
  "hash": "31f1711bc2fee6106b9122901fbc16c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  html:\n    toc: true\nexecute:\n  eval: true\n  freeze: true\n---\n\n\n\n\n\n\n<img src=\"figures/favicon/apple-touch-icon-180x180.png\" style=\"float:right\" />\n\nRun multiple LLM predictions against a data frame. The predictions are processed \nrow-wise over a specified column. It works using a pre-determined one-shot prompt,\nalong with the current row's content. The prompt that is use will depend of the\ntype of analysis needed. \n\nCurrently, the included prompts perform the following: \n\n- [Sentiment analysis](#sentiment)\n- [Text summarizing](#summarize)\n- [Classify text](#classify)\n- [Extract one, or several](#extract), specific pieces information from the text\n- [Translate text](#translate)\n- [Custom prompt](#custom-prompt)\n\nThis package is inspired by the SQL AI functions now offered by vendors such as\n[Databricks](https://docs.databricks.com/en/large-language-models/ai-functions.html) \nand Snowflake.  `mall` uses [Ollama](https://ollama.com/) to  interact with LLMs \ninstalled  locally. \n\n\nFor R, that interaction takes place via the \n[`ollamar`](https://hauselin.github.io/ollama-r/) package. The functions are \ndesigned to easily work with piped commands, such as `dplyr`. \n\n```r\nreviews |>\n  llm_sentiment(review)\n```\n\n\nFor Python, `mall` includes an extension to [Polars](https://pola.rs/). To\ninteract with Ollama, it uses the official [Python library](https://github.com/ollama/ollama-python).\n\n```python\nreviews.llm.sentiment(\"review\")\n```\n\n## Motivation\n\nWe want to new find ways to help data scientists use LLMs in their daily work. \nUnlike the familiar interfaces, such as chatting and code completion, this interface\nruns your text data directly against the LLM.  \n\nThe LLM's flexibility, allows for it to adapt to the subject of your data, and \nprovide surprisingly accurate predictions. This saves the data scientist the\nneed to write and tune an NLP model. \n\nIn recent times, the capabilities of LLMs that can run locally in your computer \nhave increased dramatically. This means that these sort of analysis can run\nin your machine with good accuracy. Additionally, it makes it possible to take\nadvantage of LLM's at your institution, since the data will not leave the\ncorporate network. \n\n## Get started\n\n- Install `mall` from Github\n\n  \n::: {.panel-tabset group=\"language\"}\n## R\n```r\npak::pak(\"edgararuiz/mall/r@python\")\n```\n\n## python\n```python\npip install \"mall @ git+https://git@github.com/edgararuiz/mall.git@python#subdirectory=python\"\n```\n:::\n  \n\n### With local LLMs\n\n- [Download Ollama from the official website](https://ollama.com/download)\n\n- Install and start Ollama in your computer\n\n\n::: {.panel-tabset group=\"language\"}\n## R\n- Install Ollama in your machine. The `ollamar` package's website provides this\n[Installation guide](https://hauselin.github.io/ollama-r/#installation)\n\n- Download an LLM model. For example, I have been developing this package using\nLlama 3.2 to test. To get that model you can run: \n  ```r\n  ollamar::pull(\"llama3.2\")\n  ```\n  \n## python\n\n- Install the official Ollama library\n  ```python\n  pip install ollama\n  ```\n\n- Download an LLM model. For example, I have been developing this package using\nLlama 3.2 to test. To get that model you can run: \n  ```python\n  import ollama\n  ollama.pull('llama3.2')\n  ```\n:::\n\n\n  \n### With Databricks (R only)\n\nIf you pass a table connected to **Databricks** via `odbc`, `mall` will \nautomatically use Databricks' LLM instead of Ollama. *You won't need Ollama \ninstalled if you are using Databricks only.*\n\n`mall` will call the appropriate SQL AI function. For more information see our \n[Databricks article.](https://edgararuiz.github.io/mall/articles/databricks.html) \n\n## LLM functions\n\n### Sentiment\n\nPrimarily,  `mall` provides verb-like functions that expect a data frame as \ntheir first argument. \n\nWe will start with loading a very small data set contained in `mall`. It has\n3 product reviews that we will use as the source of our examples.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mall)\n\ndata(\"reviews\")\n\nreviews\n#> # A tibble: 3 × 1\n#>   review                                                                        \n#>   <chr>                                                                         \n#> 1 This has been the best TV I've ever used. Great screen, and sound.            \n#> 2 I regret buying this laptop. It is too slow and the keyboard is too noisy     \n#> 3 Not sure how to feel about my new washing machine. Great color, but hard to f…\n```\n:::\n\n\n\n## python\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport mall \nimport polars as pl\n\ndata = mall.MallData\n\nreviews = data.reviews\nreviews \n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 1)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th></tr><tr><td>str</td></tr></thead><tbody><tr><td>&quot;This has been the best TV I&#x27;ve…</td></tr><tr><td>&quot;I regret buying this laptop. I…</td></tr><tr><td>&quot;Not sure how to feel about my …</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n:::\n\n\n\n\n\n\n\nFor the first example, we'll asses the sentiment of each review:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nreviews |>\n  llm_sentiment(review)\n#> # A tibble: 3 × 2\n#>   review                                                              .sentiment\n#>   <chr>                                                               <chr>     \n#> 1 This has been the best TV I've ever used. Great screen, and sound.  positive  \n#> 2 I regret buying this laptop. It is too slow and the keyboard is to… negative  \n#> 3 Not sure how to feel about my new washing machine. Great color, bu… neutral\n```\n:::\n\n\n\n## python \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nreviews.llm.sentiment(\"review\")\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th><th>sentiment</th></tr><tr><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;This has been the best TV I&#x27;ve…</td><td>&quot;positive&quot;</td></tr><tr><td>&quot;I regret buying this laptop. I…</td><td>&quot;negative&quot;</td></tr><tr><td>&quot;Not sure how to feel about my …</td><td>&quot;neutral&quot;</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n\n:::\n\nWe can also provide custom sentiment labels. Use the `options` argument to control\nthat:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nreviews |>\n  llm_sentiment(review, options = c(\"positive\", \"negative\"))\n#> # A tibble: 3 × 2\n#>   review                                                              .sentiment\n#>   <chr>                                                               <chr>     \n#> 1 This has been the best TV I've ever used. Great screen, and sound.  positive  \n#> 2 I regret buying this laptop. It is too slow and the keyboard is to… negative  \n#> 3 Not sure how to feel about my new washing machine. Great color, bu… negative\n```\n:::\n\n\n\n## python \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nreviews.llm.sentiment(\"review\", options=[\"positive\", \"negative\"])\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th><th>sentiment</th></tr><tr><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;This has been the best TV I&#x27;ve…</td><td>&quot;positive&quot;</td></tr><tr><td>&quot;I regret buying this laptop. I…</td><td>&quot;negative&quot;</td></tr><tr><td>&quot;Not sure how to feel about my …</td><td>&quot;negative&quot;</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n\n:::\n\nAs mentioned before, these functions are create to play well with the rest of \nthe analysis\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nreviews |>\n  llm_sentiment(review, options = c(\"positive\", \"negative\")) |>\n  filter(.sentiment == \"negative\")\n#> # A tibble: 2 × 2\n#>   review                                                              .sentiment\n#>   <chr>                                                               <chr>     \n#> 1 I regret buying this laptop. It is too slow and the keyboard is to… negative  \n#> 2 Not sure how to feel about my new washing machine. Great color, bu… negative\n```\n:::\n\n\n\n## python\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nx = reviews.llm.sentiment(\"review\", options=[\"positive\", \"negative\"])\n\nx.filter(pl.col(\"sentiment\") == \"negative\")\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (2, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th><th>sentiment</th></tr><tr><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;I regret buying this laptop. I…</td><td>&quot;negative&quot;</td></tr><tr><td>&quot;Not sure how to feel about my …</td><td>&quot;negative&quot;</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n\n:::\n\n### Summarize\n\nThere may be a need to reduce the number of words in a given text. Typically to \nmake it easier to understand its intent. The function has an argument to \ncontrol the maximum number of words to output \n(`max_words`):\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\n\nreviews |>\n  llm_summarize(review, max_words = 5)\n#> # A tibble: 3 × 2\n#>   review                                        .summary                      \n#>   <chr>                                         <chr>                         \n#> 1 This has been the best TV I've ever used. Gr… it's a great tv               \n#> 2 I regret buying this laptop. It is too slow … laptop purchase was a mistake \n#> 3 Not sure how to feel about my new washing ma… having mixed feelings about it\n```\n:::\n\n\n\n## python \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\n\nreviews.llm.summarize(\"review\", 5)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th><th>summary</th></tr><tr><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;This has been the best TV I&#x27;ve…</td><td>&quot;it&#x27;s a great tv&quot;</td></tr><tr><td>&quot;I regret buying this laptop. I…</td><td>&quot;laptop not worth the money&quot;</td></tr><tr><td>&quot;Not sure how to feel about my …</td><td>&quot;feeling uncertain about new pu…</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n\n:::\n\nTo control the name of the prediction field, you can change `pred_name` argument.\n**This works with the other `llm` functions as well.**\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nreviews |>\n  llm_summarize(review, max_words = 5, pred_name = \"review_summary\")\n#> # A tibble: 3 × 2\n#>   review                                        review_summary                \n#>   <chr>                                         <chr>                         \n#> 1 This has been the best TV I've ever used. Gr… it's a great tv               \n#> 2 I regret buying this laptop. It is too slow … laptop purchase was a mistake \n#> 3 Not sure how to feel about my new washing ma… having mixed feelings about it\n```\n:::\n\n\n\n## python \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nreviews.llm.summarize(\"review\", max_words = 5, pred_name = \"review_summary\")\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th><th>review_summary</th></tr><tr><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;This has been the best TV I&#x27;ve…</td><td>&quot;it&#x27;s a great tv&quot;</td></tr><tr><td>&quot;I regret buying this laptop. I…</td><td>&quot;laptop not worth the money&quot;</td></tr><tr><td>&quot;Not sure how to feel about my …</td><td>&quot;feeling uncertain about new pu…</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n\n:::\n\n### Classify\n\nUse the LLM to categorize the text into one of the options you provide: \n\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreviews |>\n  llm_classify(review, c(\"appliance\", \"computer\"))\n#> # A tibble: 3 × 2\n#>   review                                        .classify\n#>   <chr>                                         <chr>    \n#> 1 This has been the best TV I've ever used. Gr… computer \n#> 2 I regret buying this laptop. It is too slow … computer \n#> 3 Not sure how to feel about my new washing ma… appliance\n```\n:::\n\n\n\n\n## python \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nreviews.llm.classify(\"review\", [\"computer\", \"appliance\"])\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th><th>classify</th></tr><tr><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;This has been the best TV I&#x27;ve…</td><td>&quot;appliance&quot;</td></tr><tr><td>&quot;I regret buying this laptop. I…</td><td>&quot;appliance&quot;</td></tr><tr><td>&quot;Not sure how to feel about my …</td><td>&quot;appliance&quot;</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n\n:::\n\n### Extract \n\nOne of the most interesting use cases Using natural language, we can tell the \nLLM to return a specific part of the text. In the following example, we request\nthat the LLM return the product being referred to. We do this by simply saying \n\"product\". The LLM understands what we *mean* by that word, and looks for that\nin the text.\n\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreviews |>\n  llm_extract(review, \"product\")\n#> # A tibble: 3 × 2\n#>   review                                        .extract       \n#>   <chr>                                         <chr>          \n#> 1 This has been the best TV I've ever used. Gr… tv             \n#> 2 I regret buying this laptop. It is too slow … laptop         \n#> 3 Not sure how to feel about my new washing ma… washing machine\n```\n:::\n\n\n\n\n## python \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nreviews.llm.extract(\"review\", \"product\")\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th><th>extract</th></tr><tr><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;This has been the best TV I&#x27;ve…</td><td>&quot;tv&quot;</td></tr><tr><td>&quot;I regret buying this laptop. I…</td><td>&quot;laptop&quot;</td></tr><tr><td>&quot;Not sure how to feel about my …</td><td>&quot;washing machine&quot;</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n\n:::\n\n\n### Translate\n\nAs the title implies, this function will translate the text into a specified \nlanguage. What is really nice, it is that you don't need to specify the language\nof the source text. Only the target language needs to be defined.  The translation\naccuracy will depend on the LLM\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\n\nreviews |>\n  llm_translate(review, \"spanish\")\n#> # A tibble: 3 × 2\n#>   review                                        .translation                    \n#>   <chr>                                         <chr>                           \n#> 1 This has been the best TV I've ever used. Gr… Esta ha sido la mejor televisió…\n#> 2 I regret buying this laptop. It is too slow … Me arrepiento de comprar este p…\n#> 3 Not sure how to feel about my new washing ma… No estoy seguro de cómo me sien…\n```\n:::\n\n\n\n\n## python \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\n\nreviews.llm.translate(\"review\", \"spanish\")\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th><th>translation</th></tr><tr><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;This has been the best TV I&#x27;ve…</td><td>&quot;Esta ha sido la mejor TV que h…</td></tr><tr><td>&quot;I regret buying this laptop. I…</td><td>&quot;Lo lamento comprar este portát…</td></tr><tr><td>&quot;Not sure how to feel about my …</td><td>&quot;No estoy seguro de cómo sentir…</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n\n:::\n\n### Custom prompt\n\nIt is possible to pass your own prompt to the LLM, and have `mall` run it \nagainst each text entry:\n\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_prompt <- paste(\n  \"Answer a question.\",\n  \"Return only the answer, no explanation\",\n  \"Acceptable answers are 'yes', 'no'\",\n  \"Answer this about the following text, is this a happy customer?:\"\n)\n\nreviews |>\n  llm_custom(review, my_prompt)\n#> # A tibble: 3 × 2\n#>   review                                                                   .pred\n#>   <chr>                                                                    <chr>\n#> 1 This has been the best TV I've ever used. Great screen, and sound.       Yes  \n#> 2 I regret buying this laptop. It is too slow and the keyboard is too noi… No   \n#> 3 Not sure how to feel about my new washing machine. Great color, but har… No\n```\n:::\n\n\n\n\n## python \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nmy_prompt = \"Answer a question.\" \\\n  + \"Return only the answer, no explanation\" \\\n  + \"Acceptable answers are 'yes', 'no'\" \\\n  + \"Answer this about the following text, is this a happy customer?:\"\n\n\nreviews.llm.custom(\"review\", prompt = my_prompt)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>review</th><th>custom</th></tr><tr><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;This has been the best TV I&#x27;ve…</td><td>&quot;Yes&quot;</td></tr><tr><td>&quot;I regret buying this laptop. I…</td><td>&quot;No&quot;</td></tr><tr><td>&quot;Not sure how to feel about my …</td><td>&quot;No&quot;</td></tr></tbody></table></div>\n```\n\n:::\n:::\n\n\n\n:::\n\n## Model selection and settings\n\nYou can set the model and its options to use when calling the LLM. In this case,\nwe refer to options as model specific things that can be set, such as seed or\ntemperature. \n\n::: {.panel-tabset group=\"language\"}\n## R\n\nInvoking an `llm` function will automatically initialize a model selection\nif you don't have one selected yet. If there is only one option, it will \npre-select it for you. If there are more than one available models, then `mall`\nwill present you as menu selection so you can select which model you wish to \nuse.\n\nCalling `llm_use()` directly will let you specify the model and backend to use.\nYou can also setup additional arguments that will be passed down to the \nfunction that actually runs the prediction. In the case of Ollama, that function\nis [`chat()`](https://hauselin.github.io/ollama-r/reference/chat.html). \n\nThe model to use, and other options can be set for the current R session\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nllm_use(\"ollama\", \"llama3.2\", seed = 100, temperature = 0)\n```\n:::\n\n\n\n\n## python \n\nThe model and options to be used will be defined at the Polars data frame \nobject level. If not passed, the default model will be **llama3.2**.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nreviews.llm.use(options = dict(seed = 100))\n```\n:::\n\n\n\n:::\n\n## Key considerations\n\nThe main consideration is **cost**. Either, time cost, or money cost.\n\nIf using this method with an LLM locally available, the cost will be a long \nrunning time. Unless using a very specialized LLM, a given LLM is a general model. \nIt was fitted using a vast amount of data. So determining a response for each \nrow, takes longer than if using a manually created NLP model. The default model\nused in Ollama is [Llama 3.2](https://ollama.com/library/llama3.2), \nwhich was fitted using 3B parameters. \n\nIf using an external LLM service, the consideration will need to be for the \nbilling costs of using such service. Keep in mind that you will be sending a lot\nof data to be evaluated. \n\nAnother consideration is the novelty of this approach. Early tests are \nproviding encouraging results. But you, as an user, will still need to keep\nin mind that the predictions will not be infallible, so always check the output.\nAt this time, I think the best use for this method, is for a quick analysis.\n\n## Performance\n\nWe will briefly cover this methods performance from two perspectives: \n\n- How long the analysis takes to run locally \n\n- How well it predicts \n\nTo do so, we will use the `data_bookReviews` data set, provided by the `classmap`\npackage. For this exercise, only the first 100, of the total 1,000, are going\nto be part of this analysis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(classmap)\n\ndata(data_bookReviews)\n\ndata_bookReviews |>\n  glimpse()\n#> Rows: 1,000\n#> Columns: 2\n#> $ review    <chr> \"i got this as both a book and an audio file. i had waited t…\n#> $ sentiment <fct> 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, …\n```\n:::\n\n\nAs per the docs, `sentiment` is a factor indicating the sentiment of the review:\nnegative (1) or positive (2)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(strsplit(paste(head(data_bookReviews$review, 100), collapse = \" \"), \" \")[[1]])\n#> [1] 20470\n```\n:::\n\n\n\nJust to get an idea of how much data we're processing, I'm using a very, very \nsimple word count. So we're analyzing a bit over 20 thousand words.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreviews_llm <- data_bookReviews |>\n  head(100) |> \n  llm_sentiment(\n    col = review,\n    options = c(\"positive\" ~ 2, \"negative\" ~ 1),\n    pred_name = \"predicted\"\n  )\n#> ! There were 2 predictions with invalid output, they were coerced to NA\n```\n:::\n\n\n\nAs far as **time**, on my Apple M3 machine, it took about 1.5 minutes to process,\n100 rows, containing 20 thousand words. Setting `temp` to 0 in `llm_use()`, \nmade the model run faster.\n\nThe package uses `purrr` to send each prompt individually to the LLM. But, I did\ntry a few different ways to speed up the process, unsuccessfully:\n\n- Used `furrr` to send multiple requests at a time. This did not work because \neither the LLM or Ollama processed all my requests serially. So there was\nno improvement.\n\n- I also tried sending more than one row's text at a time. This cause instability\nin the number of results. For example sending 5 at a time, sometimes returned 7\nor 8. Even sending 2 was not stable. \n\nThis is what the new table looks like:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreviews_llm\n#> # A tibble: 100 × 3\n#>    review                                        sentiment             predicted\n#>    <chr>                                         <fct>                     <dbl>\n#>  1 \"i got this as both a book and an audio file… 1                             1\n#>  2 \"this book places too much emphasis on spend… 1                             1\n#>  3 \"remember the hollywood blacklist? the holly… 2                             2\n#>  4 \"while i appreciate what tipler was attempti… 1                             1\n#>  5 \"the others in the series were great, and i … 1                             1\n#>  6 \"a few good things, but she's lost her edge … 1                             1\n#>  7 \"words cannot describe how ripped off and di… 1                             1\n#>  8 \"1. the persective of most writers is shaped… 1                            NA\n#>  9 \"i have been a huge fan of michael crichton … 1                             1\n#> 10 \"i saw dr. polk on c-span a month or two ago… 2                             2\n#> # ℹ 90 more rows\n```\n:::\n\n\n\nI used `yardstick` to see how well the model performed. Of course, the accuracy\nwill not be of the \"truth\", but rather the package's results recorded in \n`sentiment`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(forcats)\n\nreviews_llm |>\n  mutate(predicted = as.factor(predicted)) |>\n  yardstick::accuracy(sentiment, predicted)\n#> # A tibble: 1 × 3\n#>   .metric  .estimator .estimate\n#>   <chr>    <chr>          <dbl>\n#> 1 accuracy binary         0.980\n```\n:::\n\n\n\n## Vector functions (R only)\n\n`mall` includes functions that expect a vector, instead of a table, to run the\npredictions. This should make it easier to test things, such as custom prompts\nor results of specific text. Each `llm_` function has a corresponding `llm_vec_`\nfunction:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nllm_vec_sentiment(\"I am happy\")\n#> [1] \"positive\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nllm_vec_translate(\"Este es el mejor dia!\", \"english\")\n#> [1] \"It's the best day!\"\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}